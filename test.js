import test from 'ava';
import {some} from 'lodash';
import {exec} from 'child_process';

import {Context} from 'shipment';
import monitor, {Process} from './';

import eventFactories from './eventFactories';
import eventReducers from './eventReducers';

import {stdout} from 'test-console';

const SubContext = Context.extend(Context, eventFactories, eventReducers);

const contains = (stdout, line) => some(stdout, l => l.match(line));

const spawn = (cmd = 'echo "hoi" "hallo"') => {

    // Spawn child process (shell)
    let childProcess = exec(cmd);

    // Instantiate Process handle
    return new Process(cmd, childProcess);
};

/**
 * Return the stdout of the test process generated by running the given function
 * (voodoo magic)
 *
 * @param fn
 * @param silent If true, doesn't output the stdout that is generated
 *
 * @returns {Promise.<string>}
 */
const capture = async (fn, {silent = false} = {}) => {

    // Hijack stdout
    let inspect = stdout.inspect();

    await fn();

    // Restore stdout
    inspect.restore();

    // Log output for debugging
    if (!silent) console.log(inspect.output.join(''));

    // Return output;
    return inspect.output;
};

test.serial('monitor', async t => {

    const context = new SubContext();

    const output = await capture(async () => {

        await(monitor(context, spawn()));
    });

    // Assert that the output contains a formatted object with stdout: hoi
    t.true(some(output, line => {
        let obj = JSON.parse(line);
        return obj.stdout && obj.stdout.match(/hoi hallo/);
    }));
});

test.serial('CLI reporter', async t => {

    const context = new SubContext({
        cli: true
    });

    const output = await capture(async () => {

        await(monitor(context, spawn()));
    });

    t.true(contains(output, /hoi hallo/));

    t.true(contains(output, /echo "hoi" "hallo"/));
});

test.serial('Non-zero exitcode', async t => {

    const process = spawn('exit 1');

    await t.throws(monitor(new SubContext(), process));
});

test.serial('SIGKILL', async t => {

    const process = spawn('sleep 10');

    const child = process.childProcess;

    setTimeout(() => child.kill(), 1000);

    await t.throws(monitor(new SubContext(), process));
});